import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { assert } from "chai";

// These types come from `target/types/...` generated by `anchor build`
import { AccountConstraintVulnerable } from "../target/types/account_constraint_vulnerable";
import { AccountConstraintFixed } from "../target/types/account_constraint_fixed";

describe("missing-account-constraint", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const vulnProgram = anchor.workspace.AccountConstraintVulnerable as Program<AccountConstraintVulnerable>;
  const fixedProgram = anchor.workspace.AccountConstraintFixed as Program<AccountConstraintFixed>;

  // actors
  const owner = provider.wallet; // default test wallet
  const attacker = anchor.web3.Keypair.generate();

  // PDAs (we will derive using owner's pubkey)
  let vaultPda: anchor.web3.PublicKey;
  let bump: number;

  it("vulnerable: initialize vault as owner", async () => {
    [vaultPda, bump] = await anchor.web3.PublicKey.findProgramAddressSync(
      [Buffer.from("vault"), owner.publicKey.toBuffer()],
      vulnProgram.programId
    );

    // initialize with balance = 100
    await vulnProgram.methods
      .initialize(new anchor.BN(100))
      .accounts({
        vault: vaultPda,
        owner: owner.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

    const vault = await vulnProgram.account.vault.fetch(vaultPda);
    assert.equal(vault.owner.toBase58(), owner.publicKey.toBase58());
    assert.equal(vault.balance.toNumber(), 100);
  });

  it("vulnerable: attacker can withdraw because constraint missing", async () => {
    // attacker signs and calls withdraw on the vulnerable program
    await vulnProgram.methods
      .withdraw(new anchor.BN(40))
      .accounts({
        vault: vaultPda,
        caller: attacker.publicKey,
      })
      .signers([attacker])
      .rpc();

    const vault = await vulnProgram.account.vault.fetch(vaultPda);
    // Balance should be reduced even though attacker is not owner
    assert.equal(vault.balance.toNumber(), 60);
  });

  it("fixed: initialize vault for fixed program", async () => {
    // derive PDA for fixed program using same owner seed logic
    const [vaultFixedPda, _bump2] = await anchor.web3.PublicKey.findProgramAddressSync(
      [Buffer.from("vault"), owner.publicKey.toBuffer()],
      fixedProgram.programId
    );

    // init fixed vault
    await fixedProgram.methods
      .initialize(new anchor.BN(100))
      .accounts({
        vault: vaultFixedPda,
        owner: owner.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

    const vault = await fixedProgram.account.vault.fetch(vaultFixedPda);
    assert.equal(vault.owner.toBase58(), owner.publicKey.toBase58());
    assert.equal(vault.balance.toNumber(), 100);

    // store for later
    vaultPda = vaultFixedPda;
  });

  it("fixed: attacker withdraw should fail", async () => {
    try {
      await fixedProgram.methods
        .withdraw(new anchor.BN(40))
        .accounts({
          vault: vaultPda,
          owner: attacker.publicKey, // attacker tries to pass as owner
        })
        .signers([attacker])
        .rpc();
      assert.fail("Expected withdrawal to be rejected");
    } catch (err: any) {
      const errStr = err.toString();
      // Anchor will throw a constraint/authorization error
      assert.include(errStr, "Constraint");
    }

    // Ensure balance is unchanged
    const vault = await fixedProgram.account.vault.fetch(vaultPda);
    assert.equal(vault.balance.toNumber(), 100);
  });
});
